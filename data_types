# DATA TYPES

BOOLEAN
TRUE, FALSE, NULL
valid literals:
TRUE, 'true', 't', 'y', 'yes', '1'
---> is_available

CHARACTER TYPES - text, number, symbol; n - no. of characters
3 main types
1) CHARACTER(n), CHAR(n)
fixed length
2) CHARACTER VARYING(n), VARCHAR(n)
variable length with limit
useful if entries can vary in length but dont want postgresql to pad the field with blanks
stores exact number of characters provided (saves space)
no default value exists
n = max number of characters
3) TEXT, VARCHAR
variable with unlimited length
(per postgresql approx 1 gb)
---> if excessive characters are all spaces, postgresql truncates the spaces to maximum legnth (n) and stores characters

NUMERIC
Can hold various types but not null
math operations can be performed
MAIN TYPES
1) Integers
-/+ whole numbers
2) Floating point
fractions of whole numbers

INTEGERS 
1)smallint
2 bytes
2) integer
4 bytes
3)bigint
8 bytes ----> value vs. cost for space

SERIAL (auto-increment)
1) smallserial 
2 bytes
2) serial
4 bytes
3) bigserial
8 bytes

DECIMALS
represent whole number + fraction
fraction represented by digits

NUMERIC(precision, scale)
precision: max number of digits to the left and the right of point
scale: number of allowable digits on the right of the point
NUMERIC(10,2) will return two digita to the right of the point
storage - variable, fixed point

Floating point types
1) REAL
allows precision to six decimal digits
4 bytes, floating
2) DOUBLE 
allows precision to 15 decimal point of precision
unlike numeric, where we specify fixed precision, the decimal point can "float" depending on number
8 bytes, floating

SELECING NUMBER TYPES
- Use integers where possible
- decimal data and calculations need to be exact -> numeric/ decimal. flaot will save space, but be careful of inexactness
- choose big enough number type by looking at your data
- with big whole numbers, use bigint only if column values constrained to fit into either smaller integer or smallint

DATE / TIME TYPES
1) DATE, CURRENT_DATE
date only
4 bytes
YYY-MM-DD
2) TIME, CURRENT_TIME
time only
8 bytes
precision - number of fractional digitals placed in second field, up to 6 digits
HH:MM          MM:SS.pppppp
HH:MM:SS       HH:MM:SS.pppppp
HHMMSS        HHMMSS.pppppp
3) TIMESTAMP
date and time
internal stored value UTC
4) TIMESTAMPTZ
date, time, timezone
5) INTERVAL
stores values - difference between dates

UUID 'Unique Universal Data Type'
powerful when combining multiple dbs
128 byte quantity algorithm generated by an algorithm that make it unique in the known universe using the same algorithm
much better than serial when it comes to uniqueness (serial only unique in specific db)
32 digits, hexadecimal, separated by hyphens
to create you need a third party UUID algorithm to generate

CREATE EXTENSION IF NOT EXIST "uuid-ossp";
SELECT uuid_generate_v1();
- uses computer mac address, current timestamp, random values
SELECT uuid_generate_v4();
- completely random

CREATE TABLE table_uuid (
	product_id UUID DEFAULT uuid_generate_v1(),
	product_name VARCHAR(100) NOT NULL
);

ARRAY
multi-lingual data storing
every data type has its own companion array type
eg. integer has integer[] array type
character has character[] array type
array data type named by appending sqaure brackets to data type name of the array elements

CREATE TABLE table_array (
	id SERIAL,
	name VARCHAR(100),
	phones text []
);

INSERT INTO table_array (name, phones)
VALUES ('kirst',ARRAY ['(801)-123-4567', '(819)-555-2222']);

SELECT name,
	phones[1]
FROM table_array;

HSTORE
stores data in key value pairs
keys & values are text strings

CREATE EXTENSION IF NOT EXISTS hstore;

CREATE TABLE table_hstore (
	book_id serial primary key,
	title varchar(100) NOT NULL,
	book_info hstore
);

INSERT INTO table_hstore (title, book_info)
VALUES ('title1',
			'
			"publisher" => "ABC publisher",
			"paper_cost" => "10.00",
			"e_cost" => "5.85"
			'
		);

SELECT book_info -> 'publisher' FROM table_hstore;

JSON
PostgreSQL has built-in support for JSON w/ greater range of processing functions and operators, complete indexing support
text under the hood
JSONB - advanced binary version of JSON

CREATE TABLE table_json (
	id SERIAL PRIMARY KEY,
	docs JSON
);

SELECT * FROM table_json;

INSERT INTO table_json (docs)
VALUES
('[1,2,3,4,5,6]'),
('[2,3,4,5,6,7]'),
('{"key":"value"}');

SELECT docs FROM table_json;

SELECT * FROM table_json
WHERE docs @> '2';

ALTER TABLE table_json
ALTER COLUMN docs TYPE JSONB;

CREATE INDEX ON table_json USING GIN (docs jsonb_path_ops);

NET ADDRESS DATA TYPE
IPv4, IPv6, MAC addresses
whenever you are storing an IP address on your db always us network address
1) cidr 
7/19 bytes
IPv4, IPv6 (IPv4 will sort before v6)
2) inet
7/19 bytes (IPv4 will sort before v6)
IPv4, IPv6, hosts and networks
3) macaddr
6 bytes
MAC addresses
4) macaddr
8 bytes
MAC addresses (EUI-64 format)
better types to use than text as they offer input error checking and specialized operators and functions
bundled with indexing suport and advanced functions and operator support

changing ip addresses to a 24byte address
set_masklen(ip,24)

transfer inet --> cid type
set_masklen(ip::cidr,24) AS cidr_24



